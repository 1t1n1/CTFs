Message d'erreur disant que le programme a de la difficulté à rouler/peut pas rouler (-150 exactement) parce que la 64 bits n'est pas supporté. Voir si je peux essayer avec windows 32 bits ou 16 bits...

Renommer le fichier à UnholyDragon.exe fait qu'il crée les fichiers UnholyDragon-[1-150].exe et les exécute. Intéressant comme comportement.

On dirait que chaque process par le second parce que après avoir callé CreateProcessA, il crash 

004A98C8: This is the call that writes the difference in the file. I'm under the impression that there is something up with the byte difference between each file. I need to 
1. Understand where this difference is decided
2. Understand how it is determined
3. Understand why it is done this way

J'en suis rendu à essayer de trouver d'où vient le 0xF0 qui est utilisé comme clé en premier. 
Je sais que à 0x004A87CB, edx prend 0xF0.

L'endroit qui get le 0xF0 au début: call à `VariantChangeTypeEx` à 004A85DD


0019FB28  05 00 00 00 00 00 00 00 00 00 E0 A0 EF B8 E8 41  ..........à ï¸èA  
0019FB38  05 00 00 00 00 00 00 00 00 07 7D C7 C5 88 BA 42  ..........}ÇÅ.ºB  
0019FB48  05 00 00 00 00 00 00 00 00 00 00 00 00 88 BA 42  ..............ºB  
0019FB58  05 00 00 00 00 00 00 00 00 07 7D C7 C5 88 BA 40  ..........}ÇÅ.º@  
0019FB68  05 00 00 00 00 00 00 00 00 00 00 00 00 88 BA 40  ..............º@  

0019FAD0  D4 FA 19 00 00 00 00 00 00 00 00 00 00 00 00 00  Ôú..............  
0019FAE0  00 00 00 00 F4 FB 19 00 CC 54 69 00 21 00 00 00  ....ôû..ÌTi.!...  
0019FAF0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FB00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FB10  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  

0019FAD0  D4 FA 19 00 05 00 00 00 00 00 00 00 00 00 E0 A0  Ôú............à   
0019FAE0  EF B8 E8 41 F4 FB 19 00 CC 54 69 00 21 00 00 00  ï¸èAôû..ÌTi.!...  
0019FAF0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FB00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FB10  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  




0019FB24  05 00 00 00 00 00 00 00 00 00 00 80 A3 1C DE 41  ............£.ÞA  
0019FB34  05 00 00 00 00 00 00 00 47 39 3C D0 6D 68 C9 43  ........G9<ÐmhÉC  
0019FB44  05 00 00 00 00 00 00 00 00 00 00 D0 6D 68 C9 43  ...........ÐmhÉC  
0019FB54  05 00 00 00 00 00 00 00 47 39 3C D0 6D 68 C9 41  ........G9<ÐmhÉA  
0019FB64  05 00 00 00 00 00 00 00 00 00 00 D0 6D 68 C9 41  ...........ÐmhÉA  

0019FACC  D0 FA 19 00 00 00 00 00 00 00 00 00 00 00 00 00  Ðú..............  
0019FADC  00 00 00 00 F0 FB 19 00 CC 54 69 00 23 00 00 00  ....ðû..ÌTi.#...  
0019FAEC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FAFC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FB0C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  

0019FACC  D0 FA 19 00 05 00 00 00 00 00 00 00 00 00 00 80  Ðú..............  
0019FADC  A3 1C DE 41 F0 FB 19 00 CC 54 69 00 23 00 00 00  £.ÞAðû..ÌTi.#...  
0019FAEC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FAFC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FB0C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  

Le 0xF0 vient de 0x004A85D4, qui est le résultat d'un call à `VariantChangeTypeEx`. Le paramètre de ce call est à 0x0019FAD0, qui est un VARIANT. Le type est VT_UI1 (0x11), et la valeur est 0xF0. Donc le 0xF0 est hardcodé dans le binaire.

new_variant_type = 3 (VT_I4), a 4 bytes integer

0019FC4C  05 00 00 00 00 00 00 00 00 00 00 00 00 00 6E 40  ..............n@  
0019FC5C  40 00 00 00 30 7C 8D 00 A0 FD 19 00 58 FF 19 00  @...0|.. ý..Xÿ..  
0019FC6C  74 98 4A 00 C8 76 90 00 01 00 00 00 FF 00 00 00  t.J.Èv......ÿ...  
0019FC7C  B4 FE 19 00 C8 76 90 00 38 00 00 00 38 00 00 00  ´þ..Èv..8...8...  
0019FC8C  F0 FE 19 00 34 54 69 00 1E 00 00 00 00 00 00 00  ðþ..4Ti.........  
0019FC9C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FCAC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FCBC  00 00 00 00 00 00 00 00 00 00 00 00 EC 14 91 00  ............ì...  
0019FCCC  4C AC 90 00 94 15 91 00 01 00 00 00 84 AC 90 00  L¬...........¬..  
0019FCDC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FCEC  00 00 00 00 01 00 00 00 00 88 29 00 E1 A3 16 00  ..........).á£..  
0019FCFC  38 00 00 00 EC 14 91 00 00 00 00 00 00 00 00 00  8...ì...........  
0019FD0C  00 00 00 00 00 00 00 00 4C AC 90 00 00 00 00 00  ........L¬......  
0019FD1C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FD2C  00 00 00 00 0B 00 00 00 00 00 00 00 00 00 00 00  ................  
0019FD3C  00 00 00 00 00 00 00 00 00 00 00 00 CC FC 19 00  ............Ìü..  
0019FD4C  00 00 00 00 00 00 00 00 00 00 00 00 DC 01 8F 00  ............Ü...  
0019FD5C  00 00 00 00 08 80 00 00 00 00 00 00 F4 08 4B 00  ............ô.K.  
0019FD6C  00 00 00 00 0B 00 00 00 00 00 00 00 FF FF 00 00  ............ÿÿ..  
0019FD7C  00 00 00 00 00 00 00 00 00 00 00 00 CC FC 19 00  ............Ìü..  
0019FD8C  00 00 00 00 00 00 00 00 00 00 00 00 04 02 8F 00  ................  

0019FBB4  B8 FB 19 00 00 00 00 00 00 00 00 00 00 00 00 00  ¸û..............  
0019FBC4  00 00 00 00 FF 00 00 00 FE 00 00 00 01 00 00 00  ....ÿ...þ.......  
0019FBD4  FF 00 00 00 00 00 00 00 80 1C EE 3F C8 76 90 00  ÿ.........î?Èv..  
0019FBE4  00 00 00 00 00 00 F0 3F 01 00 00 00 8C FC 19 00  ......ð?.....ü..  

0019FBB4  B8 FB 19 00 03 00 B2 76 05 00 00 00 F0 00 00 00  ¸û....²v....ð...  
0019FBC4  B8 FA 19 00 FF 00 00 00 FE 00 00 00 01 00 00 00  ¸ú..ÿ...þ.......  
0019FBD4  FF 00 00 00 00 00 00 00 80 1C EE 3F C8 76 90 00  ÿ.........î?Èv..  
0019FBE4  00 00 00 00 00 00 F0 3F 01 00 00 00 8C FC 19 00  ......ð?.....ü..  



So it takes the previous value as a long double and converts it to an integer. This is how 406E (or 6E40, find out which) is converted to F0.

The function receives the variant who's double will be converted as second parameter

I honestly start to think that I am getting to deep. I think the real solution is to find a way to retrieve the original VB file in some automated way, but I don't know how to do that.
I believe this because the functions I am looking at are mostly at the end of the file, which means that I am deep into a twinBASIC library and I would have to spend a uncountable amount of time to reverse engineer it.

In twinBASIC, we can confirm that OLE Automation is a library that can be included and I am assuming that this is what is creating all this Variant mess.
